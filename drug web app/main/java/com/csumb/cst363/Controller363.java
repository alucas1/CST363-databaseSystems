/**
 * AUTHORS: Gabriel De Leon, Alberto Lucas
 * DATE: 02/02/2021
 * CLASS: CST363
 * DESCRIPTION: Contains database queries for project 2 - Web APP and JDBC
 */

package com.csumb.cst363;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Random;

import javax.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class Controller363
{

   @Autowired
   private JdbcTemplate jdbcTemplate;

   /*
    * Doctor requests form to create new prescription.
    */
   @GetMapping("/prescription/new")
   public String newPrescripton(Model model)
   {
      model.addAttribute("prescription", new Prescription());
      return "prescription_create";
   }

   /*
    * Process the new prescription form. 1. Validate that Doctor SSN exists and
    * matches Doctor Name. 2. Validate that Patient SSN exists and matches
    * Patient Name. 3. Validate that Drug name exists. 4. Insert new
    * prescription. Return error message and the filled in prescription form or
    * the prescription with the rxid number generated by the database.
    */
   @PostMapping("/prescription")
   public String addPrescription(@Valid Prescription p, BindingResult result,
                                 Model model)
   {
      if (result.hasErrors())
      {
         System.out.println("Binding error in addPrescription.");
      }

      /*
       * replace following with code to validate the prescription and insert a
       * new prescription
       */
      try
      {
         // Connect to database
         Connection conn = jdbcTemplate.getDataSource().getConnection();

         // Declare variables
         String patientid = "not found";
         String drugName = "not found";
         String docid = "not found";
         String rxid = "not found";
         Boolean isDuplicate = false;
         int quantity = p.getQuantity();
         PreparedStatement ps = null;
         ResultSet rs = null;

         // Verify that doctor SSN and Name match an existing docID
         ps = conn.prepareStatement(
                 "SELECT docid FROM doctor WHERE docssn LIKE ? AND docfirstname LIKE ? AND doclastname LIKE ?");
         ps.setInt(1, p.getDoctor_ssn());
         ps.setString(2, p.getDoctorFirstName());
         ps.setString(3, p.getDoctorLastName());
         rs = ps.executeQuery();
         if (rs.next())
         {
            docid = rs.getString(1);
         }

         // Verify that patient SSN and Name match an existing patientID
         ps = conn.prepareStatement(
                 "SELECT patientid FROM patient WHERE patientssn LIKE ? AND patientfirstname LIKE ? AND patientlastname LIKE ?");
         ps.setString(1, p.getPatient_ssn());
         ps.setString(2, p.getPatientFirstName());
         ps.setString(3, p.getPatientLastName());
         rs = ps.executeQuery();
         if (rs.next())
         {
            patientid = rs.getString(1);
         }

         // Verify that drug name exists
         ps = conn.prepareStatement(
                 "SELECT drugname FROM drug WHERE drugname LIKE ?");
         ps.setString(1, p.getDrugName());
         rs = ps.executeQuery();
         if (rs.next())
         {
            drugName = rs.getString(1);
         }

         // Ensure that patient does not already have and existing prescription
         // with the same drug
         ps = conn.prepareStatement(
                 "SELECT DISTINCT rxid FROM prescription WHERE drugname LIKE ? AND patientid LIKE ?");
         ps.setString(1, drugName);
         ps.setString(2, patientid);
         rs = ps.executeQuery();
         if (rs.next())
         {
            isDuplicate = true;
         }

         // set rxid
         rxid = generateRandomChars(10);
         p.setRxid(rxid);

         // If a duplicate prescription is found, update it.
         if (isDuplicate)
         {
            ps = conn.prepareStatement(
                    "UPDATE prescription SET rxid = ?, prescdate = NOW(), prescquantity = ?, docid = ? WHERE patientid LIKE ? AND drugname LIKE ?");
            ps.setString(1, rxid);
            ps.setInt(2, quantity);
            ps.setString(3, docid);
            ps.setString(4, patientid);
            ps.setString(5, drugName);
            model.addAttribute("usererror",
                    "Duplicate found, updating record with new rxid, qty, date, and doctorid");
         }
         else
         {
            // Insert new prescription into db
            ps = conn.prepareStatement(
                    "INSERT INTO prescription (rxid, patientid, drugname, prescquantity, docid, prescdate) VALUES (?, ?, ?, ?, ?, NOW())");
            ps.setString(1, rxid);
            ps.setString(2, patientid);
            ps.setString(3, drugName);
            ps.setInt(4, quantity);
            ps.setString(5, docid);
         }
         ps.executeUpdate();

         // Close connection and show template
         conn.close();
         return "prescription_show";

      } catch (SQLException se)
      {
         System.out.println("Error: " + se.getMessage());
         model.addAttribute("usererror",
                 "ERROR! Please go back and ensure that the information you have entered is correct. If you continue to get an error, contact your system administrator with the following message:");
         model.addAttribute("adminerror", se.getMessage());
         return "prescription_show";
      }
   }

   /*
    * patient requests the form to fill a prescription
    */
   @GetMapping("/prescription/fill")
   public String getfillForm(Model model)
   {
      model.addAttribute("prescription", new Prescription());
      return "prescription_fill";
   }

   /*
    * process the prescription fill form 1. Validate that rxid, pharmacy name
    * and pharmacy address are entered and uniquely identify a prescript and one
    * pharmacy. 2. update prescription with pharmacyid, name and address. 3.
    * update prescription with today's date. Display updated prescription or if
    * there is an error show the form with an error message.
    */
   @PostMapping("/prescription/fill")
   public String processFillForm(@Valid Prescription p, BindingResult result,
                                 Model model)
   {
      if (result.hasErrors())
      {
         System.out.println("Binding error in processFillForm.");
      }

      /*
       * replace the following code with code to validate the rxid, pharmacy
       * name and address from the database , and update the pharmacyID, cost
       * and data of the prescription
       */

      try
      {
         // Connect to database
         Connection conn = jdbcTemplate.getDataSource().getConnection();

         // Declare variables
         PreparedStatement ps = null;
         ResultSet rs = null;
         String rxid = "";
         String patientID = "";
         Boolean doesRxIDMatchPatient = false;
         Boolean doesPharmAddressMatchName = false;

         // Validating that rxid and patient name match and not previously full
         // Populates Prescription p with data
         ps = conn.prepareStatement(
                 "SELECT d.docFirstName, d.docLastName, rx.drugname, rx.prescquantity, d.docssn, p.patientssn FROM prescription rx INNER JOIN patient p ON rx.patientid = p.patientid INNER JOIN doctor d ON rx.docid = d.docid WHERE rxid LIKE ? AND patientfirstname LIKE ? AND patientlastname LIKE ? AND pharmacyfilled IS NULL");
         ps.setString(1, p.getRxid());
         ps.setString(2, p.getPatientFirstName());
         ps.setString(3, p.getPatientLastName());
         rs = ps.executeQuery();
         if (rs.next())
         {
            p.setDoctorName(rs.getString(1) + " " + rs.getString(2));
            p.setDrugName(rs.getString(3));
            p.setQuantity(rs.getInt(4));
            p.setDoctor_ssn(rs.getInt(5));
            p.setPatient_ssn(rs.getString(6));
            doesRxIDMatchPatient = true;
         }

         // Validating that pharmacy name and pharmacy address match
         // Populates Prescription p with data
         ps = conn.prepareStatement(
                 "SELECT pharmid, pharmphonenumber FROM pharmacy WHERE pharmname LIKE ?  AND pharmstreetnumber LIKE ?  AND pharmstreetname LIKE ? AND pharmcity LIKE ? AND pharmstate LIKE ? AND pharmzip LIKE ?");
         ps.setString(1, p.getPharmacyName());
         ps.setString(2, p.getPharmacyStreetNumber());
         ps.setString(3, p.getPharmacyStreetName());
         ps.setString(4, p.getPharmacyCity());
         ps.setString(5, p.getPharmacyState());
         ps.setString(6, p.getPharmacyZip());
         rs = ps.executeQuery();
         if (rs.next())
         {
            p.setPharmacyID(rs.getString(1));
            p.setPharmacyPhone(rs.getString(2));
            doesPharmAddressMatchName = true;
         }

         // If everything matches, update prescription
         if (doesPharmAddressMatchName && doesRxIDMatchPatient)
         {
            ps = conn.prepareStatement(
                    "UPDATE prescription p SET pharmacyfilled = ?, prescdatefilled = NOW() WHERE rxid LIKE ?;");
            ps.setString(1, p.getPharmacyID());
            ps.setString(2, p.getRxid());
            ps.executeUpdate();

            // update 'date filled' on template
            ps = conn.prepareStatement(
                    "SELECT prescdatefilled FROM prescription WHERE rxid LIKE ?");
            ps.setString(1, p.getRxid());
            rs = ps.executeQuery();
            if (rs.next())
            {
               p.setDateFilled(rs.getString(1));
            }

            // Update 'cost' on template
            ps = conn.prepareStatement(
                    "SELECT price FROM sells WHERE drugname LIKE ? AND pharmid LIKE ?");
            ps.setString(1, p.getDrugName());
            ps.setString(2, p.getPharmacyID());
            rs = ps.executeQuery();
            if (rs.next())
            {
               p.setCost(rs.getDouble(1) * p.getQuantity());
            }
         }
         else if (!doesPharmAddressMatchName)
         {
            model.addAttribute("usererror",
                    "Error: pharmacy name does not match pharmacy address, or prescription id already filled!");
         }
         else if (!doesRxIDMatchPatient)
         {
            model.addAttribute("usererror",
                    "Error: patient name does not match prescription id, or prescription id already filled!");
         }

         // Close connection and show template
         conn.close();
         model.addAttribute("prescription", p);
         return "prescription_show";

      } catch (SQLException se)
      {
         System.out.println("Error:" + se.getMessage());
         model.addAttribute("usererror",
                 "Please go back and ensure all data is correct. If this error persists, contact your system administrator with the following error message:");
         model.addAttribute("adminerror", se.getMessage());
         return "prescription_show";
      }
   }

   /*
    * process search request for quantity used for each drug for a given
    * pharmacy. input is pharmacyID, startDate and endDate output is drugName,
    * quantity used to fill prescriptions 1. validate pharmacyID
    */
   @GetMapping("/pharmacy")
   public String pharmacyReport(@RequestParam("pharmacyID") String pharmacyID,
                                @RequestParam("drug") String drug,
                                @RequestParam("startDate") String startDate,
                                @RequestParam("endDate") String endDate, Model model)
   {

      // replace the following code with code to perform database search
      // returning drugname and quantity used
      try
      {
         // Connect to database
         Connection conn = jdbcTemplate.getDataSource().getConnection();

         // Declare variables
         ArrayList<ReportElement1> drugs = new ArrayList<>();
         PreparedStatement ps = null;
         ResultSet rs = null;

         // Create query
         ps = conn.prepareStatement(
                 "SELECT drugname, SUM(prescquantity) FROM prescription WHERE pharmacyfilled LIKE ? AND drugname LIKE ? AND prescdatefilled BETWEEN ? AND ? GROUP BY drugname");
         ps.setString(1, pharmacyID);
         String drugWildCard = "%" + drug + "%";
         ps.setString(2, drugWildCard);
         ps.setString(3, startDate);
         ps.setString(4, endDate);

         // Execute query and gather data
         rs = ps.executeQuery();
         while (rs.next())
         {
            drugs.add(new ReportElement1(rs.getString(1), rs.getInt(2)));
            System.out.println("1");
         }

         // Close connection and show template
         conn.close();

         model.addAttribute("startDate", startDate);
         model.addAttribute("endDate", endDate);
         model.addAttribute("pharmacyID", pharmacyID);
         model.addAttribute("report", drugs);
         return "pharmacy_report";

      } catch (SQLException se)
      {
         System.out.println("Error:" + se.getMessage());
         return "pharmacy_report";
      }

   }

   /*
    * process search request for FDA of quantity of drug prescribed by doctor
    * input is drugname, date range output is doctor name, quantity prescribed
    * 1. validate the drug name (it may be a partial name of a drug)
    */
   @GetMapping("/fda")
   public String fdaReport(@RequestParam("drug") String drug,
                           @RequestParam("startDate") String startDate,
                           @RequestParam("endDate") String endDate, Model model)
   {

      /*
       * replace following code with code to perform db search for drug quantity
       * used by doctors
       */
      try
      {

         // Connect to database
         Connection conn = jdbcTemplate.getDataSource().getConnection();

         // Declare variables
         ArrayList<ReportElement1> drugs = new ArrayList<>();
         PreparedStatement ps = null;
         ResultSet rs = null;

         // SQL statement
         ps = conn.prepareStatement(
                 "SELECT d.docfirstname, d.doclastname, SUM(rx.prescquantity) FROM prescription rx INNER JOIN doctor d ON rx.docid = d.docid WHERE rx.drugname LIKE ? AND rx.prescdate BETWEEN ? AND ? GROUP BY rx.docid");
         ps.setString(1, "%" + drug + "%");
         ps.setString(2, startDate);
         ps.setString(3, endDate);

         // Execute query and gather data
         rs = ps.executeQuery();
         while (rs.next())
         {
            drugs.add(new ReportElement1(
                    rs.getString(1) + " " + rs.getString(2), rs.getInt(3)));
         }

         // display template
         model.addAttribute("startDate", startDate);
         model.addAttribute("endDate", endDate);
         model.addAttribute("drug", drug);
         model.addAttribute("report", drugs);
         return "fda_report";

      } catch (SQLException se)
      {
         System.out.println("Error" + se.getMessage());
         return "fda_report";
      }
   }

   /*
    * return JDBC Connection using jdbcTemplate in Spring Server
    */
   private Connection getConnection() throws SQLException
   {
      Connection conn = jdbcTemplate.getDataSource().getConnection();
      return conn;
   }

   // Generates a random string
   public static String generateRandomChars(int length)
   {
      String candidateChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
      StringBuilder sb = new StringBuilder();
      Random random = new Random();
      for (int i = 0; i < length; i++)
      {
         sb.append(
                 candidateChars.charAt(random.nextInt(candidateChars.length())));
      }

      return sb.toString();
   }

}